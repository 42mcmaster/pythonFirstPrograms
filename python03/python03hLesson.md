# Lesson 3h: Random Numbers and Loop Testing

## Learning Objectives
- Generate random numbers using the random module
- Create programs with random elements
- Test loops effectively
- Debug common loop errors
- Combine loops and selection for complex programs

## Generating Random Numbers

Many programs need randomness:
- Games (dice rolls, card shuffles)
- Simulations
- Random sampling
- Testing

Python's `random` module provides functions for generating random numbers.

## The random Module

### Importing

```python
import random
```

This gives you access to random number functions.

### random.randint()

Returns a random integer between two values (inclusive).

**Syntax:**
```python
random.randint(start, end)
```

**Examples:**
```python
import random

# Roll a die (1-6)
roll = random.randint(1, 6)
print(f"You rolled a {roll}")

# Pick a random age between 18 and 65
age = random.randint(18, 65)
print(f"Random age: {age}")

# Generate a random year
year = random.randint(1900, 2024)
print(f"Random year: {year}")
```

### Multiple Random Values

```python
import random

# Roll two dice
die1 = random.randint(1, 6)
die2 = random.randint(1, 6)
total = die1 + die2

print(f"Die 1: {die1}")
print(f"Die 2: {die2}")
print(f"Total: {total}")
```

**Sample Output:**
```
Die 1: 4
Die 2: 5
Total: 9
```

Each time you run it, you get different numbers!

## Example 1: Number Guessing Game

```python
import random

smaller = int(input("Enter the smaller number: "))
larger = int(input("Enter the larger number: "))

# Computer picks a random number
myNumber = random.randint(smaller, larger)
count = 0

print(f"I'm thinking of a number between {smaller} and {larger}...")

while True:
    count += 1
    userNumber = int(input("Enter your guess: "))
    
    if userNumber < myNumber:
        print("Too small!")
    elif userNumber > myNumber:
        print("Too large!")
    else:
        print(f"You've got it in {count} tries!")
        break
```

**Sample Run:**
```
Enter the smaller number: 1
Enter the larger number: 100
I'm thinking of a number between 1 and 100...
Enter your guess: 50
Too small!
Enter your guess: 75
Too large!
Enter your guess: 63
Too small!
Enter your guess: 69
Too large!
Enter your guess: 66
Too large
Enter your guess: 65
You've got it in 6 tries!
```

## Example 2: Dice Rolling Simulation

```python
import random

# Simulate rolling a die 10 times
print("Rolling a die 10 times:")
for roll in range(10):
    result = random.randint(1, 6)
    print(result, end=" ")
print()  # New line
```

**Sample Output:**
```
Rolling a die 10 times:
2 4 6 4 3 2 3 6 2 2
```

## Example 3: Rock-Paper-Scissors Game

```python
import random

choices = ["rock", "paper", "scissors"]

while True:
    # Computer makes random choice
    computer = random.randint(0, 2)  # 0=rock, 1=paper, 2=scissors
    
    print("\n1. Rock")
    print("2. Paper")
    print("3. Scissors")
    print("4. Quit")
    
    user_choice = int(input("Your choice: "))
    
    if user_choice == 4:
        print("Thanks for playing!")
        break
    
    if user_choice < 1 or user_choice > 3:
        print("Invalid choice!")
        continue
    
    user = user_choice - 1  # Convert to 0-2
    
    print(f"You chose: {choices[user]}")
    print(f"Computer chose: {choices[computer]}")
    
    if user == computer:
        print("It's a tie!")
    elif (user == 0 and computer == 2) or \
         (user == 1 and computer == 0) or \
         (user == 2 and computer == 1):
        print("You win!")
    else:
        print("Computer wins!")
```

## Random Numbers Are "Pseudo-Random"

Random numbers aren't truly random - they're generated by an algorithm.

But they're random enough for most purposes:
- Games
- Simulations
- Testing

**For the same seed, you get the same sequence:**

```python
import random

# Set the seed
random.seed(42)
print(random.randint(1, 100))  # Always the same!
print(random.randint(1, 100))  # Always the same!
```

This is useful for testing - you can reproduce the same "random" sequence.

## Other Random Functions

### random.random()
Returns a float between 0.0 and 1.0

```python
import random

# Random probability
chance = random.random()
print(f"Probability: {chance:.2f}")

# 30% chance of rain
if random.random() < 0.30:
    print("It's raining!")
```

### random.choice()
Picks a random item from a list

```python
import random

colors = ["red", "blue", "green", "yellow"]
chosen = random.choice(colors)
print(f"Random color: {chosen}")

# Pick a random card
cards = ["Ace", "King", "Queen", "Jack"]
card = random.choice(cards)
print(f"You drew: {card}")
```

## Testing Loops

Testing loops is critical - they're where many bugs hide!

### Test Strategy for Loops

1. **Test with zero iterations**
   - Will the loop run at all?
   
2. **Test with one iteration**
   - Does it work correctly once?
   
3. **Test with multiple iterations**
   - Does it work repeatedly?
   
4. **Test boundary values**
   - First and last iterations

### Example: Testing a Summation Loop

```python
# Sum numbers from start to end
def sum_range(start, end):
    total = 0
    for num in range(start, end + 1):
        total += num
    return total

# Test cases
print(sum_range(1, 0))    # Zero iterations: 0
print(sum_range(5, 5))    # One iteration: 5
print(sum_range(1, 5))    # Multiple: 15 (1+2+3+4+5)
print(sum_range(1, 100))  # Large: 5050
```

### Common Loop Errors to Test For

**1. Off-by-One Errors**
```python
# Want 1-10, but this gives 1-9
for i in range(1, 10):  # Should be range(1, 11)
    print(i)
```

**2. Infinite Loops**
```python
# Never stops!
count = 0
while count < 10:
    print(count)
    # Forgot to increment count
```

**3. Wrong Initialization**
```python
# Product should start at 1, not 0!
product = 0  # WRONG
for i in range(1, 5):
    product *= i  # Always stays 0!
```

**4. Using Loop Variable After Loop**
```python
for i in range(5):
    print(i)
# i is now 4, not 5!
print(f"Final i: {i}")  # Might not be what you expect
```

## Loop Testing Checklist

When testing a loop, verify:

- [ ] Initialization is correct
- [ ] Condition is correct
- [ ] Update/increment is correct
- [ ] Loop body does what you expect
- [ ] Loop terminates correctly
- [ ] Works with edge cases (0, 1, many iterations)
- [ ] No off-by-one errors

## Complete Example: Simulation

Let's simulate flipping a coin 1000 times:

```python
import random

heads = 0
tails = 0
flips = 1000

for flip in range(flips):
    # 0 = heads, 1 = tails
    result = random.randint(0, 1)
    if result == 0:
        heads += 1
    else:
        tails += 1

print(f"Results after {flips} flips:")
print(f"Heads: {heads} ({heads/flips*100:.1f}%)")
print(f"Tails: {tails} ({tails/flips*100:.1f}%)")
```

**Sample Output:**
```
Results after 1000 flips:
Heads: 512 (51.2%)
Tails: 488 (48.8%)
```

Should be close to 50-50!

## Debugging Techniques

### 1. Add Print Statements

```python
count = 0
total = 0

while count < 5:
    print(f"DEBUG: count={count}, total={total}")  # Debug line
    count += 1
    total += count
    
print(f"Final: {total}")
```

### 2. Check Loop Invariants

A **loop invariant** is something that should always be true.

```python
# Invariant: total equals sum of 1 to count
count = 0
total = 0

while count < 10:
    count += 1
    total += count
    # Check invariant
    expected = count * (count + 1) // 2
    assert total == expected, f"Invariant violated! {total} != {expected}"
```

### 3. Test with Known Values

```python
# We know 1+2+3+4+5 = 15
def test_sum():
    total = 0
    for i in range(1, 6):
        total += i
    assert total == 15, f"Expected 15, got {total}"
    print("Test passed!")

test_sum()
```

## Putting It All Together

Here's a complete program combining loops, selection, and random numbers:

```python
import random

def play_number_game():
    """Play a number guessing game with difficulty levels."""
    
    print("=== Number Guessing Game ===")
    print("1. Easy (1-50)")
    print("2. Medium (1-100)")
    print("3. Hard (1-500)")
    
    difficulty = int(input("Choose difficulty: "))
    
    # Set range based on difficulty
    if difficulty == 1:
        max_num = 50
        max_guesses = 10
    elif difficulty == 2:
        max_num = 100
        max_guesses = 7
    elif difficulty == 3:
        max_num = 500
        max_guesses = 10
    else:
        print("Invalid choice!")
        return
    
    # Generate random number
    secret = random.randint(1, max_num)
    guesses = 0
    
    print(f"\nI'm thinking of a number between 1 and {max_num}.")
    print(f"You have {max_guesses} guesses.")
    
    while guesses < max_guesses:
        guesses += 1
        remaining = max_guesses - guesses + 1
        
        guess = int(input(f"\nGuess #{guesses}: "))
        
        if guess == secret:
            print(f"Correct! You won in {guesses} guesses!")
            return
        elif guess < secret:
            print(f"Too low! {remaining} guesses left.")
        else:
            print(f"Too high! {remaining} guesses left.")
    
    print(f"\nSorry, you're out of guesses!")
    print(f"The number was {secret}.")

# Play the game
play_number_game()

# Ask to play again
while input("\nPlay again? (yes/no): ").lower() == "yes":
    play_number_game()

print("Thanks for playing!")
```

## Key Takeaways

1. **random.randint(a, b)** generates random integers (inclusive)
2. **Random numbers** are useful for games and simulations
3. **Test loops thoroughly** - zero, one, and many iterations
4. **Watch for off-by-one errors** - very common!
5. **Debug with print statements** - see what's happening
6. **Combine concepts** - loops + selection + random = powerful programs

## Practice

Try this in IDLE or VS Code:

```python
import random

# Experiment: Roll dice 100 times, count each outcome
counts = [0, 0, 0, 0, 0, 0]  # For values 1-6

for roll in range(100):
    result = random.randint(1, 6)
    counts[result - 1] += 1

for value in range(1, 7):
    print(f"{value}: {counts[value-1]} times")
```

Each outcome should appear roughly 16-17 times out of 100!